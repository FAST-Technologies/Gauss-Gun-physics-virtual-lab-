{"version":3,"file":"asciiArtPostProcess.js","sourceRoot":"","sources":["../../../../dev/postProcesses/src/asciiArt/asciiArtPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { serialize, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Effect } from \"core/Materials/effect\";\r\nimport { PostProcess } from \"core/PostProcesses/postProcess\";\r\nimport type { Scene } from \"core/scene\";\r\nimport \"core/Engines/Extensions/engine.dynamicTexture\";\r\nimport \"./asciiart.fragment\";\r\n\r\n/**\r\n * AsciiArtFontTexture is the helper class used to easily create your ascii art font texture.\r\n *\r\n * It basically takes care rendering the font front the given font size to a texture.\r\n * This is used later on in the postprocess.\r\n */\r\nexport class AsciiArtFontTexture extends BaseTexture {\r\n    @serialize(\"font\")\r\n    private _font: string;\r\n\r\n    @serialize(\"text\")\r\n    private _text: string;\r\n\r\n    private _charSize: number;\r\n\r\n    /**\r\n     * Gets the size of one char in the texture (each char fits in size * size space in the texture).\r\n     */\r\n    public get charSize(): number {\r\n        return this._charSize;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the Ascii Art FontTexture class\r\n     * @param name the name of the texture\r\n     * @param font the font to use, use the W3C CSS notation\r\n     * @param text the caracter set to use in the rendering.\r\n     * @param scene the scene that owns the texture\r\n     */\r\n    constructor(name: string, font: string, text: string, scene: Nullable<Scene> = null) {\r\n        super(scene);\r\n\r\n        scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.name = name;\r\n        this._text == text;\r\n        this._font == font;\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        //this.anisotropicFilteringLevel = 1;\r\n\r\n        // Get the font specific info.\r\n        const maxCharHeight = this._getFontHeight(font);\r\n        const maxCharWidth = this._getFontWidth(font);\r\n\r\n        this._charSize = Math.max(maxCharHeight.height, maxCharWidth);\r\n\r\n        // This is an approximate size, but should always be able to fit at least the maxCharCount.\r\n        const textureWidth = Math.ceil(this._charSize * text.length);\r\n        const textureHeight = this._charSize;\r\n\r\n        // Create the texture that will store the font characters.\r\n        this._texture = scene.getEngine().createDynamicTexture(textureWidth, textureHeight, false, Texture.NEAREST_SAMPLINGMODE);\r\n        //scene.getEngine().setclamp\r\n        const textureSize = this.getSize();\r\n\r\n        // Create a canvas with the final size: the one matching the texture.\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = textureSize.width;\r\n        canvas.height = textureSize.height;\r\n        const context = <CanvasRenderingContext2D>canvas.getContext(\"2d\");\r\n        context.textBaseline = \"top\";\r\n        context.font = font;\r\n        context.fillStyle = \"white\";\r\n        context.imageSmoothingEnabled = false;\r\n\r\n        // Sets the text in the texture.\r\n        for (let i = 0; i < text.length; i++) {\r\n            context.fillText(text[i], i * this._charSize, -maxCharHeight.offset);\r\n        }\r\n\r\n        // Flush the text in the dynamic texture.\r\n\r\n        scene.getEngine().updateDynamicTexture(this._texture, canvas, false, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the max char width of a font.\r\n     * @param font the font to use, use the W3C CSS notation\r\n     * @returns the max char width\r\n     */\r\n    private _getFontWidth(font: string): number {\r\n        const fontDraw = document.createElement(\"canvas\");\r\n        const ctx = <CanvasRenderingContext2D>fontDraw.getContext(\"2d\");\r\n        ctx.fillStyle = \"white\";\r\n        ctx.font = font;\r\n\r\n        return ctx.measureText(\"W\").width;\r\n    }\r\n\r\n    // More info here: https://videlais.com/2014/03/16/the-many-and-varied-problems-with-measuring-font-height-for-html5-canvas/\r\n    /**\r\n     * Gets the max char height of a font.\r\n     * @param font the font to use, use the W3C CSS notation\r\n     * @returns the max char height\r\n     */\r\n    private _getFontHeight(font: string): { height: number; offset: number } {\r\n        const fontDraw = document.createElement(\"canvas\");\r\n        const ctx = <CanvasRenderingContext2D>fontDraw.getContext(\"2d\");\r\n        ctx.fillRect(0, 0, fontDraw.width, fontDraw.height);\r\n        ctx.textBaseline = \"top\";\r\n        ctx.fillStyle = \"white\";\r\n        ctx.font = font;\r\n        ctx.fillText(\"jH|\", 0, 0);\r\n        const pixels = ctx.getImageData(0, 0, fontDraw.width, fontDraw.height).data;\r\n        let start = -1;\r\n        let end = -1;\r\n        for (let row = 0; row < fontDraw.height; row++) {\r\n            for (let column = 0; column < fontDraw.width; column++) {\r\n                const index = (row * fontDraw.width + column) * 4;\r\n                if (pixels[index] === 0) {\r\n                    if (column === fontDraw.width - 1 && start !== -1) {\r\n                        end = row;\r\n                        row = fontDraw.height;\r\n                        break;\r\n                    }\r\n                    continue;\r\n                } else {\r\n                    if (start === -1) {\r\n                        start = row;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return { height: end - start + 1, offset: start - 1 };\r\n    }\r\n\r\n    /**\r\n     * Clones the current AsciiArtTexture.\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): AsciiArtFontTexture {\r\n        return new AsciiArtFontTexture(this.name, this._font, this._text, this.getScene());\r\n    }\r\n\r\n    /**\r\n     * Parses a json object representing the texture and returns an instance of it.\r\n     * @param source the source JSON representation\r\n     * @param scene the scene to create the texture for\r\n     * @returns the parsed texture\r\n     */\r\n    public static Parse(source: any, scene: Scene): AsciiArtFontTexture {\r\n        const texture = SerializationHelper.Parse(() => new AsciiArtFontTexture(source.name, source.font, source.text, scene), source, scene, null);\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\n/**\r\n * Option available in the Ascii Art Post Process.\r\n */\r\nexport interface IAsciiArtPostProcessOptions {\r\n    /**\r\n     * The font to use following the w3c font definition.\r\n     */\r\n    font?: string;\r\n\r\n    /**\r\n     * The character set to use in the postprocess.\r\n     */\r\n    characterSet?: string;\r\n\r\n    /**\r\n     * This defines the amount you want to mix the \"tile\" or caracter space colored in the ascii art.\r\n     * This number is defined between 0 and 1;\r\n     */\r\n    mixToTile?: number;\r\n\r\n    /**\r\n     * This defines the amount you want to mix the normal rendering pass in the ascii art.\r\n     * This number is defined between 0 and 1;\r\n     */\r\n    mixToNormal?: number;\r\n}\r\n\r\n/**\r\n * AsciiArtPostProcess helps rendering everithing in Ascii Art.\r\n *\r\n * Simmply add it to your scene and let the nerd that lives in you have fun.\r\n * Example usage: var pp = new AsciiArtPostProcess(\"myAscii\", \"20px Monospace\", camera);\r\n */\r\nexport class AsciiArtPostProcess extends PostProcess {\r\n    /**\r\n     * The font texture used to render the char in the post process.\r\n     */\r\n    private _asciiArtFontTexture: AsciiArtFontTexture;\r\n\r\n    /**\r\n     * This defines the amount you want to mix the \"tile\" or caracter space colored in the ascii art.\r\n     * This number is defined between 0 and 1;\r\n     */\r\n    public mixToTile: number = 0;\r\n\r\n    /**\r\n     * This defines the amount you want to mix the normal rendering pass in the ascii art.\r\n     * This number is defined between 0 and 1;\r\n     */\r\n    public mixToNormal: number = 0;\r\n\r\n    /**\r\n     * Instantiates a new Ascii Art Post Process.\r\n     * @param name the name to give to the postprocess\r\n     * @camera the camera to apply the post process to.\r\n     * @param camera\r\n     * @param options can either be the font name or an option object following the IAsciiArtPostProcessOptions format\r\n     */\r\n    constructor(name: string, camera: Nullable<Camera>, options?: string | IAsciiArtPostProcessOptions) {\r\n        super(name, \"asciiart\", [\"asciiArtFontInfos\", \"asciiArtOptions\"], [\"asciiArtFont\"], 1, camera, Texture.TRILINEAR_SAMPLINGMODE, undefined, true);\r\n\r\n        // Default values.\r\n        let font = \"40px Monospace\";\r\n        let characterSet = \" `-.'_:,\\\"=^;<+!*?/cL\\\\zrs7TivJtC{3F)Il(xZfY5S2eajo14[nuyE]P6V9kXpKwGhqAUbOd8#HRDB0$mgMW&Q%N@\";\r\n\r\n        // Use options.\r\n        if (options) {\r\n            if (typeof options === \"string\") {\r\n                font = <string>options;\r\n            } else {\r\n                font = (<IAsciiArtPostProcessOptions>options).font || font;\r\n                characterSet = (<IAsciiArtPostProcessOptions>options).characterSet || characterSet;\r\n                this.mixToTile = (<IAsciiArtPostProcessOptions>options).mixToTile || this.mixToTile;\r\n                this.mixToNormal = (<IAsciiArtPostProcessOptions>options).mixToNormal || this.mixToNormal;\r\n            }\r\n        }\r\n\r\n        const scene = camera?.getScene() || this._scene;\r\n        this._asciiArtFontTexture = new AsciiArtFontTexture(name, font, characterSet, scene);\r\n        const textureSize = this._asciiArtFontTexture.getSize();\r\n\r\n        this.onApply = (effect: Effect) => {\r\n            effect.setTexture(\"asciiArtFont\", this._asciiArtFontTexture);\r\n\r\n            effect.setFloat4(\"asciiArtFontInfos\", this._asciiArtFontTexture.charSize, characterSet.length, textureSize.width, textureSize.height);\r\n\r\n            effect.setFloat4(\"asciiArtOptions\", this.width, this.height, this.mixToNormal, this.mixToTile);\r\n        };\r\n    }\r\n}\r\n"]}